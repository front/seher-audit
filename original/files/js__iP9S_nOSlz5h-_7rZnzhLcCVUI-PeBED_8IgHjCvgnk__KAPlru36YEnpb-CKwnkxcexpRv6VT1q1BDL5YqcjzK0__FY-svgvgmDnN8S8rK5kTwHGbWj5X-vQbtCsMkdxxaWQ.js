// Generated by CoffeeScript 1.6.3
/*
contextManager
*/


(function() {
  define('adaptive/contextManager', ['core/utils'], function(exports, utils) {
    var console, self;
    console = newConsole(exports.__id);
    self = (console.getLevel('debug') ? exports : this);
    self.handlers = [];
    self.contextName = "";
    exports.configure = function(configSettings) {
      var fn_name, handler, handlerConfig, handlers, key, _i, _j, _len, _len1, _ref, _ref1;
      configSettings = configSettings || {};
      console.info("Configuring context '" + configSettings.name + "'...");
      self.contextName = configSettings.name;
      if (!self.validateConfig(configSettings)) {
        console.debug('configSettings: ', configSettings);
      }
      if (utils.type(configSettings.handlers) === 'array') {
        handlers = configSettings.handlers;
      } else {
        handlers = [];
        _ref = configSettings.handlers;
        for (key in _ref) {
          handler = _ref[key];
          handlers.push(handler);
        }
      }
      handlers.sort(function(a, b) {
        return (a.__weight >= b.__weight ? 1 : -1);
      });
      for (_i = 0, _len = handlers.length; _i < _len; _i++) {
        handlerConfig = handlers[_i];
        handler = require(handlerConfig.moduleId);
        if (handler) {
          _ref1 = ['configure', 'initialize', 'renderLayout'];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            fn_name = _ref1[_j];
            if (typeof handler[fn_name] !== 'function') {
              console.warn("'" + handlerConfig.moduleId + "' does not export function '" + fn_name + "'!");
            }
          }
          console.log("Configuring handler '" + handlerConfig.moduleId + "'...");
          if (typeof handler.configure === 'function') {
            handler.configure(handlerConfig.settings, configSettings.name);
          }
          self.handlers.push(handler);
        }
      }
      return exports;
    };
    exports.getContextName = function() {
      return self.contextName;
    };
    exports.initialize = function(activeLayoutName, allLayoutNames) {
      var handler, _i, _len, _ref, _results;
      _ref = self.handlers;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        handler = _ref[_i];
        if (typeof handler.initialize === 'function') {
          _results.push(handler.initialize(activeLayoutName, allLayoutNames));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    exports.renderLayout = function(activeLayoutName, prevActiveLayoutName) {
      var e, handler, _i, _len, _ref, _results;
      _ref = self.handlers;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        handler = _ref[_i];
        try {
          if (typeof handler.renderLayout === 'function') {
            _results.push(handler.renderLayout(activeLayoutName, prevActiveLayoutName));
          } else {
            _results.push(void 0);
          }
        } catch (_error) {
          e = _error;
          _results.push(console.error("" + handler.__id + ".renderLayout()", e));
        }
      }
      return _results;
    };
    return self.validateConfig = function(config) {
      var valid;
      valid = true;
      if (!config.name || typeof config.name !== 'string') {
        console.error("validateConfig: 'name' is missing!");
        valid = false;
      }
      if (!utils.type(config.handlers)) {
        console.error("validateConfig: 'handlers' is missing!");
        valid = false;
      }
      return valid;
    };
  });

}).call(this);
;/**/
// Generated by CoffeeScript 1.6.3
/*
gridContextHandler
-
Handles grid layouts for a context
*/


(function() {
  var __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define('adaptive/gridContextHandler', ['jQuery', 'core/utils'], function(exports, $, utils) {
    var GridElement, GridLayout, console, self;
    console = newConsole(exports.__id);
    self = (console.getLevel('debug') ? exports : this);
    self.layouts = {};
    self.activeLayout = null;
    self.staticPropertyNames = ['contentContainerSelector', 'gridTypeSelectors', 'gridDefaultType', 'defaultLayoutName'];
    self.gridTypeKeys = [];
    exports.configure = function(configSettings) {
      var key, layouts, _, _i, _len, _ref, _ref1;
      self.cssMetaClass = configSettings.cssMetaClass || '';
      this.valid = true;
      _ref = self.staticPropertyNames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        if (configSettings[key]) {
          self[key] = configSettings[key];
        } else {
          this.valid = false;
          console.warn("ConfigSetting '" + key + "' not provided!");
        }
      }
      if (!this.valid) {
        console.error('Required configSettings not provided!');
        console.debug('configSettings: ', configSettings);
      }
      _ref1 = self.gridTypeSelectors;
      for (key in _ref1) {
        if (!__hasProp.call(_ref1, key)) continue;
        _ = _ref1[key];
        self.gridTypeKeys.push(key);
      }
      layouts = layouts || configSettings.layouts;
      if (layouts) {
        self.setLayouts(layouts);
      } else {
        console.error("No layouts provided!");
      }
      return exports;
    };
    exports.initialize = function(activeLayoutName, allLayoutNames) {
      self.contentContainerEl = $(self.contentContainerSelector).first();
      console.debug('Container-element:', self.contentContainerEl);
      if (!self.contentContainerEl.length) {
        console.warn("No DOM-element found for contentContainerSelector '" + self.contentContainerSelector + "'");
      }
      return self.defaultDomElements = $(self.gridTypeSelectors[self.gridDefaultType], self.contentContainerEl);
    };
    exports.renderLayout = function(activeLayoutName, prevActiveLayoutName) {
      var newLayout;
      newLayout = self.getLayout(activeLayoutName);
      if (newLayout) {
        if (newLayout === self.activeLayout) {
          console.log("No need to switch layout! '" + self.activeLayout.name + "' already active");
        } else {
          if (self.activeLayout) {
            self.activeLayout.remove();
          }
          newLayout.apply();
          self.activeLayout = newLayout;
        }
      }
      return self.activeLayout;
    };
    exports.getLayoutName = function() {
      var _ref;
      return (_ref = self.activeLayout) != null ? _ref.name : void 0;
    };
    self.setLayouts = function(layouts) {
      var layout, name, _results;
      _results = [];
      for (name in layouts) {
        if (!__hasProp.call(layouts, name)) continue;
        layout = layouts[name];
        _results.push(self.addLayout(name, layout));
      }
      return _results;
    };
    self.addLayout = function(name, layout) {
      return self.layouts[name] = layout;
    };
    self.getLayout = function(layoutName) {
      var layout;
      layout = self.layouts[layoutName];
      if (!layout && self.defaultLayoutName) {
        if (layoutName !== self.defaultLayoutName && self.layouts[self.defaultLayoutName]) {
          console.warn("Using default layout '" + self.defaultLayoutName + "' for '" + layoutName + "'");
          layout = self.getLayout(self.defaultLayoutName);
        }
      }
      if (!layout) {
        console.error("Unconfigured layout '" + layoutName + "'");
        return;
      }
      if (layout.alias) {
        console.warn("NOTE! '" + layoutName + "' is an alias for '" + layout.alias + "'");
        layout = self.getLayout(layout.alias);
      }
      if (!(layout instanceof GridLayout)) {
        if (!layout.gridElDefinitions) {
          console.error("Layout '" + layout.name + "': 'gridElDefinitions' not provided!");
          console.debug("-Layout = ", layout);
          return;
        }
        layout = self.layouts[layoutName] = new GridLayout(layoutName, layout.gridElDefinitions, layout.gridExcessElDefinitionsLoop, layout.gridPositionalElDefinitions);
      }
      return layout;
    };
    GridElement = (function() {
      function GridElement(gridLayout, type, typeIdx, definition, definitionIdx) {
        var e, _ref;
        this.gridLayout = gridLayout;
        this.type = type;
        this.typeIdx = typeIdx;
        this.definition = definition;
        this.definitionIdx = definitionIdx;
        this.valid = true;
        if (_ref = this.type, __indexOf.call(self.gridTypeKeys, _ref) < 0) {
          this.valid = false;
          console.error("GridElement: Invalid gridType '" + this.type + "'!");
          console.debug(" -Valid types are '" + self.gridTypeKeys + "'");
        }
        try {
          this.cssLayoutClass = this.definition.cssLayoutClass || '';
          this.cssStyleClass = this.definition.cssStyleClass || '';
          this.cssMetaClass = this.getParsedCssMetaClass(this.definition.cssMetaClass);
          this.cssLayoutClass = this.cssLayoutClass.split(',').join(' ');
          this.cssStyleClass = this.cssStyleClass.split(',').join(' ');
          this.cssMetaClass = this.cssMetaClass.split(',').join(' ');
          this.contentElementSelector = definition.contentElementSelector;
          this.domEl = this.getDomEl();
          if (this.contentElementSelector) {
            this.contentElements = this.getContentElements(this.contentElementSelector);
          }
          this.topHtml = this.htmlToElement(this.definition.topHtml);
          this.bottomHtml = this.htmlToElement(this.definition.bottomHtml);
        } catch (_error) {
          e = _error;
          this.valid = false;
          console.error(e);
        }
        if (!this.valid) {
          console.debug("-Invalid gridElDefinition[" + this.definitionIdx + "] =", this.definition);
        }
      }

      GridElement.prototype.getParsedCssMetaClass = function(definitionCssMetaClass) {
        var classnames;
        classnames = ['grid-box'].concat(utils.getCssSelectorClassnames(self.gridTypeSelectors[this.type])).concat([this.type, this.type + '-' + (this.typeIdx + 1)]);
        if (self.cssMetaClass) {
          classnames.push(self.cssMetaClass);
        }
        if (definitionCssMetaClass) {
          classnames.push(definitionCssMetaClass);
        }
        return classnames.join(' ');
      };

      GridElement.prototype.getDomEl = function() {
        var domEl;
        domEl = this.domEl;
        if (!domEl) {
          if (this.type === self.gridDefaultType) {
            domEl = $(self.defaultDomElements[this.typeIdx]);
            if (!domEl.length) {
              this.valid = false;
              console.error("Could not find default domElement for gridElement[" + this.definitionIdx + "]!");
              console.warn("-Not enough default domElements provided from the backend? (Default-type idx:" + this.typeIdx + ", max is " + (self.defaultDomElements.length - 1) + ")");
            }
          } else {
            domEl = $(document.createElement('div'));
            this.gridLayout.insertGridDomEl(domEl, this.definitionIdx);
          }
          if (domEl) {
            domEl.addClass(this.cssMetaClass);
          }
        }
        return domEl;
      };

      GridElement.prototype.showDomEl = function() {
        var elementSet, _i, _len, _ref;
        this.domEl.addClass(this.cssStyleClass);
        this.domEl.addClass(this.cssLayoutClass);
        if (this.topHtml) {
          this.domEl.prepend(this.topHtml);
        }
        if (this.contentElements) {
          _ref = this.contentElements;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            elementSet = _ref[_i];
            this.domEl.append(elementSet);
          }
          this.domEl.attr('data-set', this.contentElementSelector);
        }
        if (this.bottomHtml) {
          this.domEl.append(this.bottomHtml);
        }
        return this.domEl.show();
      };

      GridElement.prototype.hideDomEl = function() {
        this.domEl.removeClass(this.cssLayoutClass);
        this.domEl.removeClass(this.cssStyleClass);
        if (this.type !== self.gridDefaultType) {
          this.domEl.hide();
        }
        if (this.topHtml) {
          this.topHtml.remove();
        }
        if (this.bottomHtml) {
          return this.bottomHtml.remove();
        }
      };

      GridElement.prototype.htmlToElement = function(html) {
        var e, element;
        try {
          if (html != null ? html.jquery : void 0) {
            element = html;
          } else if (typeof html === 'string' && !html.trim().match('^<.*?>$')) {
            element = $("<div>" + html + "</div>");
          } else {
            element = $(html);
          }
        } catch (_error) {
          e = _error;
          element = $("<div class='htmlToElement-parse-error'>" + html + "</div>");
        }
        return element;
      };

      GridElement.prototype.getContentElements = function(contentElementSelector) {
        var contentEls, result, selector, _i, _len, _ref;
        contentEls = [];
        _ref = contentElementSelector.split(',');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          selector = _ref[_i];
          result = $(selector);
          if (result.length) {
            contentEls.push(result);
          }
        }
        if (contentEls.length === 0) {
          this.valid = false;
          console.error("gridElement[" + this.definitionIdx + "]: No contentElements found!");
        } else {
          $(contentElementSelector).find('script').remove();
        }
        return contentEls;
      };

      return GridElement;

    })();
    return GridLayout = (function() {
      var definitionDefaults;

      definitionDefaults = {
        cssLayoutClass: '',
        cssStyleClass: '',
        cssMetaClassnames: [],
        gridElDefinitions: [],
        gridExcessElDefinitionsLoop: [],
        gridPositionalElDefinitions: {}
      };

      function GridLayout(name, gridElDefinitions, gridExcessElDefinitionsLoop, gridPositionalElDefinitions) {
        this.name = name;
        console.info("Constructing Layout '" + this.name + "'");
        this.gridTypeCounts = {};
        this.setGridElDefinitions(gridElDefinitions, gridExcessElDefinitionsLoop, gridPositionalElDefinitions);
        this.setGridElements(this.gridElDefinitions);
      }

      GridLayout.prototype.resetGridTypeCounts = function() {
        var selector, type, _ref, _results;
        _ref = self.gridTypeSelectors;
        _results = [];
        for (type in _ref) {
          if (!__hasProp.call(_ref, type)) continue;
          selector = _ref[type];
          _results.push(this.gridTypeCounts[type] = 0);
        }
        return _results;
      };

      GridLayout.prototype.parseDefinitionDefaults = function(definition) {
        var e, key, value;
        try {
          if (!definition.type) {
            definition.type = self.gridDefaultType;
          }
          for (key in definitionDefaults) {
            if (!__hasProp.call(definitionDefaults, key)) continue;
            value = definitionDefaults[key];
            if (typeof definition[key] === 'undefined') {
              definition[key] = value;
            }
          }
        } catch (_error) {
          e = _error;
          console.error('parseDefinitionDefaults: #{key}', typeof definition, e);
        }
        return definition;
      };

      GridLayout.prototype.setGridElDefinitions = function(gridElDefinitions, gridExcessElDefinitionsLoop, gridPositionalElDefinitions) {
        var definition, excessCount, excessElIdx, idx, _i, _j, _len, _len1;
        this.resetGridTypeCounts();
        this.gridElDefinitions = [];
        for (idx = _i = 0, _len = gridElDefinitions.length; _i < _len; idx = ++_i) {
          definition = gridElDefinitions[idx];
          if (!(typeof definition === 'object')) {
            continue;
          }
          this.parseDefinitionDefaults(definition);
          this.gridElDefinitions.push(definition);
          this.incrementGridTypeCount(definition.type);
        }
        if (this.getGridTypeCount(self.gridDefaultType) < self.defaultDomElements.length && utils.type(gridExcessElDefinitionsLoop) === 'array') {
          for (_j = 0, _len1 = gridExcessElDefinitionsLoop.length; _j < _len1; _j++) {
            definition = gridExcessElDefinitionsLoop[_j];
            this.parseDefinitionDefaults(definition);
            definition.cssMetaClassnames.push('excess');
          }
          excessCount = 0;
          while (true) {
            if (this.getGridTypeCount(self.gridDefaultType) === self.defaultDomElements.length) {
              break;
            }
            excessElIdx = excessCount % gridExcessElDefinitionsLoop.length;
            definition = gridExcessElDefinitionsLoop[excessElIdx];
            definition = utils.cloneObj(definition);
            this.gridElDefinitions.push(definition);
            this.incrementGridTypeCount(definition.type);
            excessCount++;
          }
        }
        if (gridPositionalElDefinitions) {
          for (idx in gridPositionalElDefinitions) {
            if (!__hasProp.call(gridPositionalElDefinitions, idx)) continue;
            definition = gridPositionalElDefinitions[idx];
            console.log("Inserting gridPositional at index " + idx);
            console.debug("-gridPositionalElDefinitions[" + idx + "]:", definition);
            this.gridElDefinitions.splice(idx, 0, definition);
          }
        }
        return this.gridElDefinitions;
      };

      GridLayout.prototype.setGridElements = function(gridElDefinitions) {
        var definition, definitionIdx, gridEl, typeIdx, _i, _len, _ref;
        this.gridElements = [];
        this.gridDomElements = [];
        this.resetGridTypeCounts();
        _ref = this.gridElDefinitions;
        for (definitionIdx = _i = 0, _len = _ref.length; _i < _len; definitionIdx = ++_i) {
          definition = _ref[definitionIdx];
          typeIdx = this.getGridTypeCount(definition.type);
          gridEl = new GridElement(this, definition.type, typeIdx, definition, definitionIdx);
          this.gridElements.push(gridEl);
          this.gridDomElements.push(gridEl.domEl);
          this.incrementGridTypeCount(definition.type);
        }
        return this.gridElements;
      };

      GridLayout.prototype.incrementGridTypeCount = function(type) {
        return ++this.gridTypeCounts[type];
      };

      GridLayout.prototype.getGridTypeCount = function(type) {
        return this.gridTypeCounts[type];
      };

      GridLayout.prototype.remove = function() {
        var gridEl, gridIdx, _ref;
        console.info("Removing layout '" + this.name + "'...");
        _ref = this.gridElements;
        for (gridIdx in _ref) {
          if (!__hasProp.call(_ref, gridIdx)) continue;
          gridEl = _ref[gridIdx];
          gridEl.hideDomEl();
        }
        console.log("Removed layout '" + this.name + "'!");
        return this;
      };

      GridLayout.prototype.apply = function() {
        var gridEl, gridElIdx, _i, _len, _ref;
        $('#main-content').hide();
        console.info("Applying active layout '" + this.name + "'...");
        _ref = this.gridElements;
        for (gridElIdx = _i = 0, _len = _ref.length; _i < _len; gridElIdx = ++_i) {
          gridEl = _ref[gridElIdx];
          gridEl.showDomEl();
        }
        $('#main-content').show();
        console.log("Applied layout '" + this.name + "'!");
        return this;
      };

      GridLayout.prototype.insertGridDomEl = function(domEl, gridIdx) {
        var anchorDomEl, classNames, e, gridElDefinition, insertFnName, offset;
        if (gridIdx === 0) {
          insertFnName = 'before';
          anchorDomEl = this.gridDomElements[0] || self.defaultDomElements[0];
        } else {
          insertFnName = 'after';
          offset = 1;
          while (!(anchorDomEl != null ? anchorDomEl.length : void 0) && offset <= gridIdx) {
            anchorDomEl = this.gridDomElements[gridIdx - offset];
            offset++;
          }
        }
        gridElDefinition = this.gridElDefinitions[gridIdx];
        classNames = utils.arrayJoinNonEmpty([gridElDefinition.cssLayoutClass, gridElDefinition.cssStyleClass, gridElDefinition.cssMetaClass], '|');
        console.log("Inserting gridElement[" + gridIdx + "]: '" + classNames + "'");
        console.debug("Type='" + this.gridElDefinitions[gridIdx].type + "', " + insertFnName + " ", anchorDomEl);
        try {
          return $(anchorDomEl)[insertFnName](domEl);
        } catch (_error) {
          e = _error;
          return console.error('insertGridDomEl:', e);
        }
      };

      return GridLayout;

    })();
  });

}).call(this);
;/**/
(function() {
  /**
   * styleHandler - functionality for handling complex style maipulations
   */
  define('global/styleHandler', ['jQuery'], function(exports, $) {

    var console, self;
    console = newConsole(exports.__id);
    self = (console.getLevel('debug') ? exports : this);

    exports.stylesheetDisable = function(el) {
      var href = $(el).attr('href');
      if ( href ) {
        el.attr( '_href', href );
        el.removeAttr( 'href' );
      }
    }

    exports.stylesheetReenable = function(el) {
      var href = $(el).attr('_href');
      if ( href ) {
        el.attr( 'href', href );
        el.removeAttr( '_href' );
      }
    }

    exports.stylesheetSetMediaAll = function(el) {
      var media = $(el).attr('media');
      if ( media && media != 'all' ) {
        el.attr( '_media', media );
        el.attr( 'media', 'all' );
      }
    }

    exports.stylesheetResetMediaAll = function(el) {
      var media = $(el).attr('_media');
      if ( media ) {
        el.attr( 'media', media );
        el.removeAttr( '_media' );
      }
    }

    /**
     * Special handler to enforce stylesheet toggling for "adaptive/layoutManager.setForcedLayout()"
     * Decided to put this functionality in it's own pure JS-function rather than
     * having it inside the layout manager, since it is "custom" to the names of our responsive stylesheets...
     *
     * FIXME! Simplify this function!
     */
    exports.forcedLayoutStylesheetToggler = function() {
      var layoutManager = require('adaptive/layoutManager');
      var layoutNames = layoutManager.getLayoutNames();
      var forcedLayoutName = layoutManager.hasForcedLayout();

      /* Helpers 1: Get source- and target-attribute names depending on forcedLayoutName;
       * -Used to move the attribute-values back and forth between the real attribute and a
       *  storage attribute prefixed by '_' */
      var getSrcName = function(name) { return (forcedLayoutName ? name : '_'+name); }
      var getTargetName = function(name) { return (!forcedLayoutName ? name : '_'+name); }
      // Helpers 2: get the values of the source and target attributes using the first helpers...
      var getSrcAttr = function(el, name) { return $(el).attr(getSrcName(name)); }
      var getTargetAttr = function(el, name) { return $(el).attr(getTargetName(name)); }

      // Get all the mediaLinks: rel-stylesheets with media attribute
      var stylesheets = $('link[rel="stylesheet"]').filter('['+getSrcName('media')+']')

      // Do the work
      var filePattern, filter, matches, el;
      for (var i=0;i<layoutNames.length;i++) {
        // Make filepattern for layoutName to match our responsive stylesheet filenames
        filePattern = 'responsive.'+layoutNames[i].replace(/_/g, '.');
        // Genererate the filter pattern
        filter = "["+getSrcName('href')+"*='"+filePattern+"']";
        // Filter stylesheets vs the filename-patterns and handle matches
        matches = stylesheets.filter(filter);

        console.debug( getSrcName('href'), matches.length, filter );

        if (!matches.length) {
          // No match on this stylesheet
          continue;
        }
        // We have an element match
        el = $(matches[0]);
        // Check that the element has a href-value, either a real one or a storage
        href = getSrcAttr(el, 'href');
        if ( href ) {
          // We have a href value, lets toggle attributes around
          if (layoutNames[i] == forcedLayoutName) {
            /* The forced layout must have a media-query of "all", and the element must no be disabled:
             * -Since 'forcedLayoutName' will be 'false' when no layout is forced, this block will only kick in
             *  when 'forcedLayoutName' is set. On ''
             * 1. Store the original 'media' value
             * 2. Set the new value to 'all' */
            el.attr( getTargetName('media'), getSrcAttr(el, 'media') );
            el.attr( getSrcName('media'), 'all' );
            /* Add href-target, but do not remove the src attribute for the forced layout; otherwise the element is
             * excluded by the file-pattern filter since it will not have the '_href'-attribute! */
            el.attr( getTargetName('href'), href );
          }
          else {
            // Toggle stylesheet on/off by swapping the 'href' with '_href' to disable, and vice-versa to enable
            el.attr( getTargetName('href'), href );
            el.removeAttr( getSrcName('href') );
            // Due to the "media='all'" on the forced layoutName, we
            el.attr( getTargetName('media'), getSrcAttr(el, 'media') );
            el.removeAttr( getSrcName('media') );
          }
        }
      }
      console.info('forcedLayoutStylesheetHandler ('+forcedLayoutName+'): Stylesheets toggled!');
    }

    /**
     * Class StyleToggler - toggles a set of styles on or off
     *
     * FIXME! This code was copied from a dfp-template, so it could propbably be rewritten to behave better...
     *
     * Usage:
     *  sToggler = new styleHandler.StyleToggler({'<selectors>': { style: value, style: value }});
     *  sToggler.toggle(<true|false|undefined>);
     * -Where true: apply new styles object, false: reverse to original styles, undefined: toggle state
     *
     * WARNING! Toggling styles works *directly* with the css-values, and sets the style ON THE ELEMENT!
     * -So toggling off will set the css-values to their original value, but NOT the element back to the original state!!
     * -removeStyles() will remove the css-styles set on the element! -But will also remove any previously styles set on the element itself!
     */
    exports.StyleToggler = (function() {

      // Constructor
      function StyleToggler(stylesObj) {
        this.newStylesObj = stylesObj;
        // Initial state
        this.newStylesFlag = false;
        // Extract origStyles values
        this.origStylesObj = this._handler(stylesObj, 'copy');
      }

      StyleToggler.prototype.getState = function() {
        return this.newStylesFlag;
      }

      StyleToggler.prototype.toggle = function(newStylesFlag) {
        if (newStylesFlag == undefined) {
          // Reverse current state
          this.newStylesFlag = !this.newStylesFlag;
        } else {
          if (this.newStylesFlag == newStylesFlag)  {
            // Same state, nothing to do
            return;
          }
          this.newStylesFlag = newStylesFlag;
        }

        if (this.newStylesFlag == true) {
          // Apply the new styles
          var stylesObj = this.newStylesObj;
        } else {
          // Re-apply original styles
          var stylesObj = this.origStylesObj;
        }
        // Apply the styleObj
        this._handler(stylesObj, 'apply');
      };

      StyleToggler.prototype.removeStyles = function() {
        this.newStylesFlag = false;
        this._handler(this.newStylesObj, 'remove');
      };

      StyleToggler.prototype._handler = function(stylesObj, action) {
        if (action == 'apply') {
          // Default to true; apply the passed styles' values
        }
        else if (action == 'copy') {
          // Only read out the current styles' values
          var currentStyles = {};
        }
        else if (action == 'remove') {
          // Remove the style
        }
        else {
          console.error("StyleToggler: Illegal action!");
          console.trace();
          return;
        }

        for (selectorStr in stylesObj) {
          if (!stylesObj.hasOwnProperty(selectorStr)) continue;
          var newStyles = stylesObj[selectorStr];
          var selectors = selectorStr.split(',');
          for(var i=0;i<selectors.length;i++) {
            var selector = selectors[i].trim();
            if (!selector) continue;
            for (style in newStyles) {
              if (!newStyles.hasOwnProperty(style)) continue;
              if ( action == 'apply' ) {
                // Apply the style's value
                $(selector).css(style, newStyles[style]);
              }
              else if ( action == 'copy' ) {
                // Store the style's value for return
                if (currentStyles[selector] == undefined) {
                  currentStyles[selector] = {};
                }
                currentStyles[selector][style] = $(selector).css(style);
              }
              else if ( action == 'remove' ) {
                // Rmove the css style
                $(selector).css(style, "");
              }
            }
          }
        }
        if (action == 'copy') { return currentStyles; }
      }
      // Return the StyleToggler
      return StyleToggler;
    })();

  });
}).call(this);




;/**/
(function() {
  /**
   * MicroMenu - builds a menu DOM-element by adding menu-items
   */
  define('global/microMenu', ['jQuery'], function(exports, $) {
    var console, self;
    console = newConsole(exports.__id);
    self = (console.getLevel('debug') ? exports : this);

    // Class MicroMenu
    exports.MicroMenu = (function() {

      // Constructor
      function MicroMenu(title, options) {
        var self = this;
        options = options || {};
        self.menuId = options.menuId || '';
        self.wrapperMarkup = options.containerMarkup || '<div></div>';
        self.menuMarkup = options.menuMarkup || '<div></div>';
        self.itemMarkup = options.menuItemMarkup || '<div></div>';

        if (!$(title).length) {
          // Need to wrap title in an element
          title = '<div>'+title+'</div>';
        }
        self.titleEl = $(title);
        self.menuItems = [];

        // Create menuEl
        self.wrapperEl = $(self.wrapperMarkup);
        if (self.menuId) {
          self.wrapperEl.attr('id', self.menuId);
        }
        self.menuEl = $(self.menuMarkup);
        self.wrapperEl.append( self.titleEl );
        self.wrapperEl.append( self.menuEl );

        // Add classNames
        self.wrapperEl.addClass('micro-menu')
        self.titleEl.addClass('micro-menu-title');
        self.menuEl.addClass('micro-menu-items');
      }

      // Call this to get the menu
      MicroMenu.prototype.getMenuElement = function() {
        var self = this;
        self.refresh();
        return self.wrapperEl;
      }

      /**
       * NOTE! The generatorFn function MUST handle the events
       * and MUST return something that can be rendered as html,
       */
      MicroMenu.prototype.addItem = function(generatorFn, className) {
        if ( typeof(generatorFn) != 'function') {
          console.error("MicroMenu.addItem: The menuOption MUST be a function returning the menu content!");
          return;
        }
        var self = this;
        self.menuItems.push({
          'generatorFn': generatorFn,
          'className': className
        });
      }

      MicroMenu.prototype.refresh = function() {
        var self = this;
        self.menuEl.empty();
        var item = null;
        var itemEl;
        for (var i=0; i<self.menuItems.length;i++) {
          item = self.menuItems[i];
          // Build menuItem element
          itemEl = $(self.itemMarkup);
          // Generate content
          itemEl.html( item.generatorFn() );
          itemEl.addClass('micro-menu-item');
          if (item.className) {
            itemEl.addClass(item.className);
          }
          console.debug(item, itemEl.html());
          // Add it to the menuEl
          self.menuEl.append( itemEl );
        }
      }
      // Return the MicroMenu
      return MicroMenu;
    })();

    /**
     * Standard menuitem generator functions. Usage:
     *
     * var microMenu = require('global/microMenu')
     * var mm = new microMenu.MicorMenu();
     * mm.addItem( microMenu.stockMenuItems.versionSelect )
     */
    exports.stockMenuItems = {
      'versionSelect': function() {
        try {
          layoutManager = require('adaptive/layoutManager');
          var forcedLayout = layoutManager.hasForcedLayout();
          // Build elements
          var itemEl = $('<div id="toggle-version"></div>');
          // Fullversion radio
          var radioEl = $('<input type="radio" name="toggle-version" value="desktop-version">');
          if ( forcedLayout ) { radioEl.attr('checked', true); }
          radioEl.click(function() { layoutManager.setForcedLayout('desktop'); });
          itemEl.append( $('<div class="option">Vis fullversjon</div>').prepend(radioEl) );
          // Mobile (adaptive) radio
          var radioEl = $('<input type="radio" name="toggle-version" value="adaptive-version">');
          if ( !forcedLayout ) { radioEl.attr('checked', true); }
          radioEl.click(function() { layoutManager.setForcedLayout(false); });
          itemEl.append( $('<div class="option">Vis mobilversjon</div>').prepend(radioEl) );
        } catch(e) {
          console.error(e);
        }
        return itemEl;
      }
    }

  });
}).call(this);
;/**/
(function() {
  define('global/stickyElement', ['jQuery',
                                  'adaptive/layoutManager'], function(exports, $, layoutManager) {
    var console, self;
    console = newConsole(exports.__id);
    self = (console.getLevel('debug') ? exports : this);
    self.contentElms = null;                       // Elements to be made sticky, passed as an array containing objects
    self.banLayoutNames = null;                    // Ban certain layoutNames from stickyness?
    self.isOnBannedLayout = false;                 // Flag if the current active layout is on the ban-list or not
    self.isInitialized = false;                    // Flag for isInitialized
    exports.initialize = function(options) {
      self.options = options || {}; // Make options an object we can assign stuff to.
      self.topAdjustment = options.topAdjustment || 0; // If we have a sticky header, configure this (with the header height as the value)
      self.contentElms = options.contentElms; // Which element do we want to target/make sticky?
      self.banLayoutNames = options.banLayoutNames || ['smartphone_landscape', 'smartphone_portrait']; // Do not use stickyness on these banned layoutNames
      layoutManager.registerChangeListener(function(activeLayoutName, preLayoutName) { // Register a callback handler for layoutName changes
        self.isOnBannedLayout = self.checkIsOnBannedLayout(activeLayoutName); // This callback will kick inn on layoutManager.initialize(), so it will do the initial handling
        self.handle(); // Call handling
      });
      $(window).scroll(function() { self.handle(); }); // Add the handler functionality to window.scroll
      self.isInitialized = true; // Flag that we are initialized
      console.info("StickyElement initialized.");
    }

    // Banned layout checking
    self.checkIsOnBannedLayout = function(activeLayoutName, preLayoutName) {
      var isOnBannedLayout = false;
      if ( self.banLayoutNames.indexOf(activeLayoutName ) > -1 ) {
        isOnBannedLayout = true;
        console.log("isBannedLayout: ", activeLayoutName);
      }
      return isOnBannedLayout;
    }

    // Self-aware handling function
    self.handle = function() {
      if (!self.isOnBannedLayout) {
        var scroll_top = $(window).scrollTop();
        if (self.contentElms.length > 0) {
          for (var i = 0; i < self.contentElms.length; i++) {

            // Define which element that contains the stickyad. Actual sticky element will be accessed as element.contentMovable
            element = self.contentElms[i];

            // Calculate things related to the element
            element.values = {
              unstickvalue: 10000000,
              valid_element: function(el){ return (!($(el).parent().parent().attr('class') === 'content-bottom-hidden')) ? ($.contains(document.documentElement, $(el)[0])) : false; },
              get_topoffset: function(el){ return (element.values.valid_element(el)) ? parseInt($(el).offset().top - $(element.contentMovable).height()) : element.values.unstickvalue; },
              get_unstickvalue: function(){ return (element.values.get_topoffset(element.extraUnstickEl) < element.values.get_topoffset(element.unstickEl)) ? element.values.get_topoffset(element.extraUnstickEl) : element.values.get_topoffset(element.unstickEl); }
            };

            // Margin compensations.
            try {
              element.stickPoint = parseInt($(element.contentEl).offset().top - self.topAdjustment);
              element.unstickValue = parseInt(element.values.get_unstickvalue() - self.topAdjustment - parseInt($(element.contentEl).css('margin-bottom')));
              element.is_sticky = (scroll_top >= element.stickPoint && scroll_top <= element.unstickValue);
            } catch (e) {}

            // Actual stick/unstick handling.
            if (element.is_sticky) {

              // Make element sticky by adding the position_fixed css class.
              $(element.contentMovable).addClass('position_fixed');
              $(element.contentMovable).css('top', self.topAdjustment + 'px');
              console.log((element.unstickEl) ? element.contentEl + ' set sticky until it reaches top of specified element' : element.contentEl + ' made sticky down to infinity.');

            } else {

              // Remove element stickyness
              if (scroll_top > element.unstickValue){

                // Element reached unstickvalue. Set a temporary top position.
                $(element.contentMovable).removeClass('position_fixed');
                element.temptop = parseInt(element.unstickValue - element.stickPoint);
                $(element.contentMovable).css('top', element.temptop + 'px');
                console.log(element.contentEl + ' no longer sticky (unstickEl reached). Margin-top of ' + element.temptop + ' now added to the element.');

              } else {

                // Element should be at original position. Set top position to zero.
                $(element.contentMovable).removeClass('position_fixed');
                $(element.contentMovable).css('top', '0px');
                console.log(element.contentEl + ' no longer sticky.');
              }
            }
          }
        }
      }
    }
  });
}).call(this);
;/**/
(function() {
  /**
   * Dfp Wallpaper
   * Ties in with the ad-template used by the wallpaer-ad in DFP (TRAFFIC) and the stickyHeader-module.
   * Used the layoutManager to register a clean-up callback on layout-change
   */
  define('traffic/dfpWallpaper', ['jQuery',
                                 'global/styleHandler',
                                 'adaptive/layoutManager'], function(exports, $, styleHandler, layoutManager) {
    var console, self;
    console = newConsole(exports.__id);
    self = (console.getLevel('debug') ? exports : this);

    // Configs
    self.wallpaperSelector = '';
    self.bannerTopSelector = '';
    // Data
    self.dfpData = null;
    self.styleToggler = null;
    self.wallpaperEl = null;
    self.bannerTopEl = null;
    // Css style objects
    self.cssRules = null;
    // Sticky masthead states
    self.mastheadState = {
      'isSticky': false,
      'topOffset': 0
    };
    // Flags
    self.isInitialized = false;

    exports.initialize = function(settings) {
      settings = settings || {};
      if ( settings['wallpaperSelector'] ) {
        self.wallpaperSelector = settings['wallpaperSelector'];
      } else {
        self.wallpaperSelector = ($('#body-wallpaper').length ? '#body-wallpaper' : 'body');
      }
      self.bannerTopSelector = (settings['bannerTopSelector'] || '#area-banner-top-creative-container');
      self.stickyMastheadSelector = (settings['stickyMastheadSelector'] || '#primary-menu-bar-wrapper.is-sticky');

      // Set elements
      self.wallpaperEl = $(self.wallpaperSelector);
      self.bannerTopEl = $(self.bannerTopSelector);

      /* Pay attention to the stickyMasthead: We need to store its states so that we can adjust
       * the wallpaper topOffset accoringly _when_ the wallpaper is set */
      $(document).on('stickymasthead', function(evt, isSticky, topOffset) {
        self.mastheadState.isSticky = isSticky;
        self.mastheadState.topOffset = topOffset;
      });
      // Flag that we are initialized
      self.isInitialized = true;
    }

    /**
     * Default wallaper-element styles
     */
    self.getStyleDeclaration = function(imageUrl, backgroundAttachement) {
      var styleDeclaration =  {
        'background-image': 'url("'+imageUrl+'")',
        'background-repeat': 'no-repeat',
        'background-position': 'center top',
        'background-attachment': (backgroundAttachement ? backgroundAttachement : 'fixed'),
        'margin-top': '0px',
        'cursor': 'hand',
        'cursor': 'pointer'
      };
      return styleDeclaration;
    }

    /**
     * This function is called by the Dfp-wallpaper template through "require('core').locate('setDfpWallpaper')".
     * -This means that the function can be overridden by exporting another function by the same name
     *  on another module which is loaded _after_ this module!
     */
    exports.setDfpWallpaper = function(dfpData) {
      console.log("setDfpWallpaper");

      if (!self.isInitialized) {
        console.error("Not initialized! Please call '"+exports.__id+".initialize()' on page ready!");
        console.info("Usually done from a context-handler's '.pageReady()'-function");
        console.trace();
        return;
      }

      if (!dfpData['clickUrl'] || !dfpData['imageUrl']) {
        console.error('Missing data: Can not set dfp wallpaper!', dfpData);
        return;
      }
      // Store a ref to the data passed from DFP
      self.dfpData = dfpData;

      // Build cssRules for the selectors
      self.cssRules = {};
      self.cssRules[self.wallpaperSelector] = self.getStyleDeclaration( dfpData['imageUrl'], 'fixed' );
      self.cssRules[self.bannerTopSelector] = self.getStyleDeclaration( dfpData['imageUrl'], 'scroll');

      // Make a new StyleToggler
      self.styleToggler = new styleHandler.StyleToggler(self.cssRules);

      // Toggle wallpaperstyles 'on' using the styleToggler
      console.log('Toggling wallpaper ON!');
      self.styleToggler.toggle(true);

      // Add wallpaper clickhandler (The bannerTop already has the clickevent set from DFP's side)
      self.wallpaperEl.bind('click.wallpaper', self.clickHandler);

      // Add handler to adjust wallpaper styles to masthead states
      $(document).on('stickymasthead', function() {
        self.adjustToMasthead();
      });
      // Do the first adjustment
      self.adjustToMasthead();

      // Register an unpersistent (called only once!) callback on layoutchange
      layoutManager.registerChangeListener(self.removeHandler, {'persist': false});
    }

    /**
     * On-click handler
     */
    self.clickHandler = function(evt) {
      try {
        /* Make sure the wallpaper-element is the actual click-target, so that
         * propagated click-events is filterd away */
        if ( $(evt.target).is( self.wallpaperEl ) ) {
          window.open(decodeURIComponent(self.dfpData['clickUrl']));
        }
      } catch(e) {
        console.error(e)
      }
    }

    self.removeHandler = function() {
      // Toggle wallpaperstyle 'off' when layout changes away from 'desktop'
      console.log('Toggling wallpaper OFF!');
      self.styleToggler.toggle(false);
      // Remove clickhandler
      self.wallpaperEl.unbind('click.wallpaper');
      // Remove adjustmenthandler
      $(document).unbind('stickymasthead', self.adjustToMasthead);
    }

    /**
     * Handler to ajust wallpaper stickyness to a sticky top-menu
     */
    self.adjustToMasthead = function() {
      try {
        if ( self.mastheadState.isSticky ) {
          // Set sticky state
          self.wallpaperEl.css({'background-attachment': 'fixed', 'background-position': '50% '+self.mastheadState.topOffset+'px'});
          self.bannerTopEl.css({'margin-top': self.mastheadState.topOffset+'px'});
          console.log('toggleSticky: sticky masthead');
        }
        else {
          // Remove sticky state
          self.wallpaperEl.css({'background-attachment': 'scroll', 'background-position': '50% 0px'});
          self.bannerTopEl.css({'margin-top': '0px'});
          console.log('toggleSticky: non-sticky masthead');
        }
      } catch(e) {
        console.error(e);
      }
    }
  });
}).call(this);




;/**/
/*
context handler - siteHandler
*/


(function() {

  define('contexts/siteHandler', [
    'jQuery',
    'global/microMenu',
    'global/stickyElement',
    'traffic/dfpWallpaper',
  ], function(exports, $, microMenu, stickyElement, dfpWallpaper) {

    var console, self;
    console = newConsole(exports.__id);
    self = (console.getLevel('debug') ? exports : this);

    /******************************************************
     * Called on contexManager initialize.js
     ******************************************************/
    exports.configure = function(configSettings, contextName) {
      self.contextName = contextName
      self.configSettings = configSettings;
      // Return: Important! MUST return exports for chaining!!
      return exports;
    };

    /*****************************************************
     * Called from layoutManager.notifyReadyListeners
     *****************************************************/
    exports.initialize = function(activeLayoutName, allLayoutNames) {
      self.initializePage();

      if ( self.contextName == 'frontpage' ) {
        self.initializeFrontpage();
      }
      else if ( self.contextName == 'node__article' ) {
        self.initializeArticlepage();
      }
      else if (self.contextName == 'node__terningkast') {
        self.initializeDicethrowPage();
      }
    };

    /******************************************************
     * Called from layoutManager.notifyChangeListeners
     *****************************************************/
    exports.renderLayout = function(activeLayoutName, prevActiveLayoutName) {
      if (!prevActiveLayoutName) {
        /* First render! -Custom 'onload' code goes here! */
       }
      else if (activeLayoutName === prevActiveLayoutName) {
        /* No need to switch layout! 'activeLayoutName' already active */
      }
      else {
        if (prevActiveLayoutName) {
          /* Remove layout 'prevActiveLayoutName'! -Custom code goes here (per layoutName) */
        }
        /* Apply layout 'activeLayoutName'! -Custom code goes here (per layoutName) */
        if (self.contextName == 'node__article') {
          self.adjustArticlePage(activeLayoutName, prevActiveLayoutName);
        }
      }
      self.adjustAfterAdScaling();
      //self.setDeviceWidthAndScale();


    };


    /*****************************************************
     * All pages
     *****************************************************/
    self.initializePage = function() {
      // Initialize the dfpWallpaper-handler
      try {
        dfpWallpaper.initialize();
      } catch(e) {
        console.error(e);
        console.debug(dfpWallpaper);
      }

      // SUBFRONT
      if (
        $('.page-kjendis')[0] ||
        $('.page-royal')[0] ||
        $('.page-brudd-og-bryllup')[0] ||
        $('.page-mor-og-barn')[0] ||
        $('.page-janthomaslive')[0] ||
        $('.page-stjernestil')[0]
      ) {
        self.initializeSubFrontpage();
      }


      // MASTHEAD MENUS
      self.mobileMenuButtonSetup();
      //self.siteOptionsMenuSetup(); // Uncomment to add options menu
      //require('adaptive/layoutManager').setForcedLayout('desktop');


      // Keeps header-region inside masthead so the menu stays fixed
      $('.mobile-menu-icon').after($('.header-region'));


      // SUPERBOARD
      $('.block-id-superboard').addClass('nomargin');

      // Adds video overlays tv page
      if ($('.page-tv')[0]){
        $('.content-top h2').before('<div class="sehertvlogo"><img src="./files/sehertv_logo.png"></div>');
        $('.sehertvlogo').wrap('<div class="whitestrip-header"></div>');
      }

      if ($('.node-type-terningkast')[0]){
        //$('.field-name-rate-integration').insertBefore('.field-name-field-file-image-head-text');
      }

    }

    /******************************************************
     * Frontpage
     *****************************************************/
    self.initializeFrontpage = function() {

      self.imageFormatSwap();

      $(document).ready(function() {

        $('.block-25').insertBefore('.kongelig');
        $('.block-26').insertBefore('.kjendis');
        $('.attach-below').after('<div class="redline"></div>');
        $('.most-read').append($('#newsletter'));
        $('#main-content').after('<div class="top-button"><a href="#">Gå til toppen av siden</a></div>');

        $(".views-field-title").each(function() {
            var item = $(this);
            item.insertAfter(item.next());
        });

        // Place the banner-unders within the right place.
        $(".vignette-banner-under").each(function() {
          $('.views-field .field-content:has(a img)', $(this).parent()).append($(this)).css({'position': 'relative'});
          $(this).css({'position': 'absolute', 'bottom': '0px', 'top': 'auto', 'z-index': '99'});
        });

      });

    }


    /******************************************************
     * Subfrontpage
     *****************************************************/
    self.initializeSubFrontpage = function() {

      self.imageFormatSwap();

      // Add frontpage class to subfrontpages
      if (
        $('.page-kjendis')[0] || $('.page-royal')[0] || $('.page-janthomaslive')[0] ||
        $('.page-brudd-og-bryllup')[0] || $('.page-mor-og-barn')[0]
      ) {
        $('body').addClass('page-frontpage')
        //self.initializeFrontpage();
      }

      // Adds video overlays tv page
      if ($('.page-tv')[0]){
        $('.content-top h2').before('<div class="sehertvlogo"><img src="./files/sehertv_logo.png"></div>');
        $('.sehertvlogo').wrap('<div class="whitestrip-header"></div>');
      }

      // Organise red carpet page - insert in inverted order after top item.
      if ($(".page-stjernestil")[0]){
        $('.view-display-id-stjernestil .views-row-1').after(
          $('.view-latest-hotornot-and-terningkast-articles'),   // 4 items
          $('.Kast-terning-på-kjendisene'),                      // 1 item
          $('.Latest-best-dressed-articles')
        )
      } else {
        // Add frontpage class to subfrontpages
        $('body').addClass('page-frontpage')
      }

      $('#main-content').after('<div class="top-button"><a href="#">Gå til toppen av siden</a></div>')

    }


    /******************************************************
     * Articlepage
     *****************************************************/
    self.initializeArticlepage = function() {

      $('.field-name-body').wrapInner('<div class="field-name-body-inner bodywidth"></div>');
      self.initializeArticleAdvertisement();

      // Content elements
      $('.field-name-field-tags').after($('.addthis_toolbox'));
      $('.block-disqus').before($('#block-block-1'));
      $('#area-netboard').after($('.field-name-field-image-article'));
      $('.field-name-related-articles-based-on-tag').after($('.addthis_toolbox'));
      $('.field-name-post-date').after($('.view-byline'));

      // Digitale bilag (to be removed within 2014).
      if ($('#plapre_bilag').length == 1){
        if ($(window).width() > 640) $('#area-articleboard').after($('#plapre_bilag'));
        else $('.field-name-related-articles-based-on-tag').before($('#plapre_bilag'));
      }

      // Get caption for inline images from img title attribute.
      $('.inline_image img').each(function() {
        $(this).after('<div class="caption">' + $(this).attr('title') + '</div>');
      });


      // Stickyboard
      stickyElement.initialize({               // Stickyboard configuration
        topAdjustment: 85,                     // Compensate for the (fixed positioned) header height
        contentElms: [{
          contentEl: '#stickywrapper',         // Container of the sticky element
          contentMovable: '#area-stickyboard', // The actual sticky element
          unstickEl: '#footer-wrapper',        // Sticky element should stop beeing sticky when it reaches top of this element
          extraUnstickEl: '#area-superboard'   // If we have an element that might appear (but not allways), do specify this as well
        }]
      });

    }


    /******************************************************
     * Misc. helper functions
     *****************************************************/

    // Update images on layout change
    self.imageFormatSwap = function() {
      if ($.isReady) {
        self.swapImageSrc();
      }
      else {
        $(document).ready(function() {
          self.swapImageSrc();
        })
      }
    }

    // Update Imagefly on layout change
    self.swapImageSrc = function() {
      var activeLayoutName = require('adaptive/layoutManager').getLayoutName();
      if (activeLayoutName == 'smartphone_portrait' || activeLayoutName == 'smartphone_landscape') {
        window.imgflySrc = 'data-mobile-src';
        window.imgflyAspect = 'data-mobile-aspect';
        $('.box-node').children('.desktop').remove();
      }
      else {
        window.imgflySrc = 'data-src';
        window.imgflyAspect = 'data-aspect';
        $('.box-node').children('.mobile').remove();
      }
    }


    self.initializeArticleAdvertisement = function() {

      $('.field-name-body').prepend( $('#area-netboard') );
      $('#area-netboard').after('<div id="right-content"></div>');
      self.initializeRightColumn();

      $('.block-latest').before($('#area-bunnbanner'))

      $('.content-bottom').after($('#area-superboard'));

      // ADSENSE
      $('.field-name-body').prepend($('#adsense-artikkel-topp'));
      $('.block-main').after($('#adsense-artikkel-midt'));
      $('#page').append($('#adsense-artikkel-bunn'));

      if ($(window).width() >= 768) {
        $('#area-netboard').addClass('advertisement is-scalable').show();
        $('#area-articleboard').addClass('advertisement is-scalable').show();
        $('#area-filmstrip').addClass('advertisement is-scalable').show();
        $('#area-stickyboard').addClass('advertisement is-scalable').show();
        $('#area-superboard').addClass('advertisement is-scalable').show();
      }
    }

    self.initializeRightColumn = function() {
      if ($(window).width() >= 768) {
        $('#right-content').append($('#area-articleboard'));
        $('#right-content').append($('#area-buttons-wrapper'));
        $('#right-content').append($('#area-filmstrip'));

        $('#right-content').append('<div id="stickywrapper"></div>');
        $('#stickywrapper').append($('#area-stickyboard'));
      }
    }


    self.adjustArticlePage = function() {
      // 1. Move  netboard after a p-tag in the bodytext
    }




    /******************************************************
     * Mobile menu setup
     *****************************************************/
    self.mobileMenuButtonSetup = function() {
      $('#masthead').append('<img class="mobile-menu-icon" src="./files/mobilemenu.png" alt="Show mobile menu" />');
      $('.mobile-menu-icon').click(
        function(){
          $('.header-region ul').toggleClass('display-mobile-menu');
        }
      );
    }


    /******************************************************
     * Advertisement setup
     *****************************************************/
    self.adjustAfterAdScaling = function() {
      var layoutManager = require('adaptive/layoutManager');
      var StyleToggler = require('global/styleHandler').StyleToggler;

      self.adStyleTogglers = self.adStyleTogglers || [];

      console.info("adjustAfterAdScaling for "+self.contextName+" "+layoutManager.getLayoutName()+": "+self.adStyleTogglers.length+" styleToggler(s) applied");
      if (self.adStyleTogglers.length) {
        console.debug(self.adStyleTogglers);
      }

      self.setDeviceWidthAndScale = function () {
        var adapted_width = (window.innerWidth <= 480) ? 'device-width' : 980; // Values reflect 1) max size to get mobile, 2) mobile and 3) desktop.
        var initial_scale = (window.innerWidth <= 480) ? 1 : window.innerWidth/adapted_width;
        document.getElementById("viewport").setAttribute('content', 'width=' + adapted_width + ', initial-scale=' + initial_scale);
      }

      // Reset any applied ad-styles and remove the associated styletoggler
      while (self.adStyleTogglers.length) {
        var styleToggler = self.adStyleTogglers.shift();
        styleToggler.removeStyles();
      }

      if ( self.contextName == 'frontpage') {

      }

    }

  });

}).call(this);


;/**/
